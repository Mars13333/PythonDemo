# 模块详解

# 退出 Python 解释器后，再次进入时，之前在 Python 解释器中定义的函数和变量就丢失了。
# 因此，编写较长程序时，最好用文本编辑器代替解释器，执行文件中的输入内容，这就是编写 脚本 。
# 随着程序越来越长，为了方便维护，最好把脚本拆分成多个文件。
# 编写脚本还一个好处，不同程序调用同一个函数时，不用把函数定义复制到各个程序。

# 为实现这些需求，Python 把各种定义存入一个文件，在脚本或解释器的交互式实例中使用。
# 这个文件就是 模块 ；模块中的定义可以 导入 到其他模块或 主 模块（在顶层和计算器模式下，执行脚本中可访问的变量集）。

# 模块是包含 Python 定义和语句的文件。其文件名是模块名加后缀名 .py 。
# 在模块内部，通过全局变量 __name__ 可以获取模块名（即字符串）。
# 例如，用文本编辑器在当前目录下创建 fibo.py 文件，输入以下内容：


# 斐波那契数列模块
def fib(n):  # 打印斐波那契数列直到 n
    a, b = 0, 1
    while a < n:
        print(a, end=' ')
        a, b = b, a + b
    print()


def fib2(n):  # 返回斐波那契数列直到 n
    result = []
    a, b = 0, 1
    while a < n:
        result.append(a)
        a, b = b, a + b
    return result


# 现在，进入 Python 解释器，用以下命令导入该模块：
import fibo  # type: ignore

# 此操作不会直接把 fibo 中定义的函数名称添加到当前 namespace 中（请参阅 Python 作用域和命名空间 了解详情）；
# 它只是将模块名称 fibo 添加到那里。 使用该模块名称你可以访问其中的函数:
fibo.fib(1000)
'0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987'
fibo.fib2(100)
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
fibo.__name__
'fibo'

# 如果经常使用某个函数，可以把它赋值给局部变量：
fib = fibo.fib
fib(500)
'0 1 1 2 3 5 8 13 21 34 55 89 144 233 377'


# 模块包含可执行语句及函数定义。这些语句用于初始化模块，且仅在 import 语句 第一次 遇到模块名时执行。
# (文件作为脚本运行时，也会执行这些语句。)

# 每个模块都有自己的私有命名空间，它会被用作模块中定义的所有函数的全局命名空间。
# 因此，模块作者可以在模块内使用全局变量而不必担心与用户的全局变量发生意外冲突。
# 另一方面，如果你知道要怎么做就可以通过与引用模块函数一样的标记法 modname.itemname 来访问一个模块的全局变量。

# 模块可以导入其他模块。 根据惯例可以将所有 import 语句都放在模块（或者也可以说是脚本）的开头但这并非强制要求。
# 如果被放置于一个模块的最高层级，则被导入的模块名称会被添加到该模块的全局命名空间。

# 还有一种 import 语句的变化形式可以将来自某个模块的名称直接导入到导入方模块的命名空间中。 例如:
from fibo import fib, fib2  # type:ignore

fib(500)
'0 1 1 2 3 5 8 13 21 34 55 89 144 233 377'
# 这条语句不会将所导入的模块的名称引入到局部命名空间中（因此在本示例中，fibo 将是未定义的名称）。

# 还有一种变体可以导入模块内定义的所有名称：
from fibo import *  # type: ignore

fib(500)
'0 1 1 2 3 5 8 13 21 34 55 89 144 233 377'
# 这种方式会导入所有不以下划线（_）开头的名称。大多数情况下，不要用这个功能，
# 这种方式向解释器导入了一批未知的名称，可能会覆盖已经定义的名称。

# 注意，一般情况下，不建议从模块或包内导入 *，因为，这项操作经常让代码变得难以理解。
# 不过，为了在交互式会话中少打几个字，这么用也没问题。

# 模块名后使用 as 时，直接把 as 后的名称与导入模块绑定。
import fibo as fib  # type:ignore

fib.fib(500)
'0 1 1 2 3 5 8 13 21 34 55 89 144 233 377'

# 与 import fibo 一样，这种方式也可以有效地导入模块，唯一的区别是，导入的名称是 fib。
# from 中也可以使用这种方式，效果类似：
from fibo import fib as fibonacci  # type:ignore

fibonacci(500)
'0 1 1 2 3 5 8 13 21 34 55 89 144 233 377'


# 以脚本方式执行模块
# 可以用以下方式运行 Python 模块：
'python fibo.py <arguments>'

# 这项操作将执行模块里的代码，和导入模块一样，但会把 __name__ 赋值为 "__main__"。 也就是把下列代码添加到模块末尾：
if __name__ == "__main__":
    import sys

    fib(int(sys.argv[1]))


# 这个文件既能被用作脚本，又能被用作一个可供导入的模块，
# 因为解析命令行参数的那两行代码只有在模块作为“main”文件执行时才会运行：
'python fibo.py 50'
'0 1 1 2 3 5 8 13 21 34'

# 当这个模块被导入到其它模块时，那两行代码不运行：
import fibo  # type:ignore

# 这常用于为模块提供一个便捷的用户接口，或用于测试（把模块作为执行测试套件的脚本运行）。


# 模块搜索路径

# "已编译"的Python文件

# ------------------------------------------------------------------------

# 标准模块


# ------------------------------------------------------------------------

# dir()函数

# ------------------------------------------------------------------------


# 包

# 从包中导入*

# 相对导入

# 多目录导入
